[
  {
    "prompt": "Generate an ERC-20 token contract with burn functionality",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract BurnableERC20 is ERC20 {\n    using SafeMath for uint256;\n\n    constructor(uint256 initialSupply) ERC20(\"BurnableERC20\", \"BRC20\") {\n        _mint(msg.sender, initialSupply);\n    }\n\n    function burn(uint256 amount) public {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(amount <= _balanceOf(msg.sender), \"Insufficient balance\");\n\n        _burn(msg.sender, amount);\n    }\n}\n```"
  },
  {
    "prompt": "Generate an ERC-721 NFT contract with metadata storage",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\n\ncontract MyNFT is ERC721, Ownable {\n    using Strings for uint256;\n\n    struct Metadata {\n        string name;\n        string description;\n        string image;\n    }\n\n    Metadata public metadata;\n\n    constructor(string memory _name, string memory _description, string memory _image) ERC721(\"MyNFT\", \"MNY\") {\n        metadata.name = _name;\n        metadata.description = _description;\n        metadata.image = _image;\n    }\n\n    function name() public view override returns (string memory) {\n        return metadata.name;\n    }\n\n    function description() public view override returns (string memory) {\n        return metadata.description;\n    }\n\n    function imageURL() public view override returns (string memory) {\n        return metadata.image;\n    }\n\n    function tokenURI(uint256 _tokenId) public view override returns (string memory) {\n        require(_exists(_tokenId), \"Token ID does not exist\");\n\n        string memory tokenURI =\n            string(abi.encodePacked(\n                '{\"name\": \"',\n                Strings.toString(_tokenId),\n                '\", \"description\": \"',\n                metadata.description,\n                '\", \"image\": \"',\n                metadata.image,\n                '\"}'\n            ));\n\n        return tokenURI;\n    }\n}\n```"
  },
  {
    "prompt": "Create a simple crowdfunding contract with a time limit and minimum contribution",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract Crowdfunding is IERC20 {\n    using SafeMath for uint256;\n\n    // Contract variables\n    IERC20 public token;\n    address payable public owner;\n    uint256 public timeLimit;\n    uint256 public minimumContribution;\n    uint256 public collectedFunds;\n    mapping(address => uint256) public contributions;\n    bool public isOpen;\n\n    // Event for contribution\n    event Contribution(address indexed contributor, uint256 value);\n\n    // Constructor\n    constructor(\n        IERC20 _token,\n        uint256 _timeLimit,\n        uint256 _minimumContribution\n    ) {\n        token = _token;\n        owner = payable(msg.sender);\n        timeLimit = _timeLimit;\n        minimumContribution = _minimumContribution;\n        isOpen = true;\n    }\n\n    // Fallback function\n    receive() external payable {\n        require(isOpen, \"Crowdfunding is closed\");\n        require(block.timestamp <= timeLimit, \"Time limit reached\");\n        require(msg.value >= minimumContribution, \"Minimum contribution not met\");\n\n        uint256 contribution = msg.value;\n        token.transferFrom(msg.sender, address(this), contribution);\n        contributions[msg.sender] = contributions[msg.sender].add(contribution);\n        collectedFunds = collectedFunds.add(contribution);\n\n        emit Contribution(msg.sender, contribution);\n    }\n\n    // Withdraw funds\n    function withdraw() external {\n        require(msg.sender == owner, \"Only the owner can withdraw funds\");\n        require(!isOpen, \"Crowdfunding is still open\");\n\n        payable(owner).transfer(address(this).balance);\n    }\n\n    // Close crowdfunding\n    function close() external {\n        require(msg.sender == owner, \"Only the owner can close the crowdfunding\");\n        isOpen = false;\n    }\n\n    // Get collected funds\n    function getCollectedFunds() external view returns (uint256) {\n        return collectedFunds;\n    }\n\n    // Get contributions\n    function getContributions(address contributor) external view returns (uint256) {\n        return contributions[contributor];\n    }\n}\n```"
  },
  {
    "prompt": "Develop a staking contract that rewards users with tokens over time",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract StakingContract is ERC20, Ownable {\n    IERC20 public rewardToken;\n    mapping(address => uint256) public stakedBalances;\n    mapping(address => uint256) public rewards;\n    mapping(address => uint256) public lastClaimedReward;\n    uint256 public constant REWARD_INTERVAL = 1 weeks;\n    uint256 public constant REWARD_MULTIPLIER = 100;\n\n    constructor(string memory name, string memory symbol, uint256 initialSupply, IERC20 rewardTokenAddress) ERC20(name, symbol) {\n        _mint(msg.sender, initialSupply);\n        rewardToken = rewardTokenAddress;\n    }\n\n    function stake(uint256 amount) external {\n        require(amount > 0, \"Amount must be greater than zero\");\n        require(balanceOf(msg.sender) >= amount, \"Insufficient balance\");\n\n        _transfer(msg.sender, address(this), amount);\n        stakedBalances[msg.sender] += amount;\n    }\n\n    function unstake(uint256 amount) external {\n        require(stakedBalances[msg.sender] >= amount, \"Insufficient staked balance\");\n\n        _transfer(address(this), msg.sender, amount);\n        stakedBalances[msg.sender] -= amount;\n    }\n\n    function claimReward() external {\n        require(block.timestamp >= lastClaimedReward[msg.sender] + REWARD_INTERVAL, \"Reward can only be claimed every interval\");\n\n        uint256 reward = (stakedBalances[msg.sender] * (block.timestamp - lastClaimedReward[msg.sender]) * REWARD_MULTIPLIER) / REWARD_INTERVAL;\n        require(reward > 0, \"No reward to claim\");\n\n        rewardToken.transfer(msg.sender, reward);\n        rewards[msg.sender] += reward;\n        lastClaimedReward[msg.sender] = block.timestamp;\n    }\n\n    function totalRewards() external view returns (uint256) {\n        return rewards[msg.sender];\n    }\n}\n```"
  },
  {
    "prompt": "Create a multi-signature wallet contract that requires 2 of 3 signatures",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract MultiSigWallet is ReentrancyGuard {\n    using SafeMath for uint256;\n\n    // Addresses of the owners\n    address public owner1;\n    address public owner2;\n    address public owner3;\n\n    // The number of required confirmations for a transaction\n    uint8 public requiredConfirmations;\n\n    // The list of pending transactions\n    struct Transaction {\n        address payable to;\n        uint256 value;\n        uint8 confirmations;\n        bool executed;\n    }\n    Transaction[] public pendingTransactions;\n\n    // Event for when a transaction is executed\n    event TransactionExecuted(\n        address indexed from,\n        address indexed to,\n        uint256 value,\n        uint256 gasUsed\n    );\n\n    // Event for when a new owner is added\n    event OwnerAdded(address indexed owner);\n\n    // Event for when an owner is removed\n    event OwnerRemoved(address indexed owner);\n\n    // Initializes the contract with the given owners and required confirmations\n    constructor(address[] memory _owners, uint8 _requiredConfirmations) {\n        require(_owners.length >= 2, \"At least two owners are required\");\n        require(_requiredConfirmations >= 1 && _requiredConfirmations <= _owners.length, \"Invalid required confirmations\");\n\n        owner1 = _owners[0];\n        owner2 = _owners[1];\n\n        if (_owners.length > 2) {\n            owner3 = _owners[2];\n        }\n\n        requiredConfirmations = _requiredConfirmations;\n\n        // Add the initial owners\n        for (uint256 i = 0; i < _owners.length; i++) {\n            addOwner(_owners[i]);\n        }\n    }\n\n    // Adds a new owner to the contract\n    function addOwner(address _owner) external {\n        require(!isOwner(_owner), \"Owner already exists\");\n\n        _addOwner(_owner);\n    }\n\n    // Removes an owner from the contract\n    function removeOwner(address _owner) external {\n        require(isOwner(_owner), \"Owner does not exist\");\n\n        _removeOwner(_owner);\n    }\n\n    // Submits a new transaction for approval\n    function submitTransaction(address payable _to, uint256 _value) external {\n        require(isOwner(msg.sender), \"Only owners can submit transactions\");\n\n        Transaction memory newTransaction = Transaction({\n            to: _to,\n            value: _value,\n            confirmations: 0,\n            executed: false\n        });\n\n        pendingTransactions.push(newTransaction);\n    }\n\n    // Executes a transaction if enough confirmations have been received\n    function executeTransaction(uint256 _transactionIndex) external {\n        require(isOwner(msg.sender), \"Only owners can execute transactions\");\n\n        Transaction storage transaction = pendingTransactions[_transactionIndex];\n\n        require(!transaction.executed, \"Transaction already executed\");\n\n        uint8 confirmationsNeeded = requiredConfirmations - 1;\n\n        if (transaction.confirmations < confirmationsNeeded) {\n            revert(\"Not enough confirmations\");\n        }\n\n        (bool success, uint256 gasUsed) = transaction.to.call{value: transaction.value}(\"\");\n\n        require(success, \"Execution failed\");\n\n        emit TransactionExecuted(msg.sender, transaction.to, transaction.value, gasUsed);\n\n        transaction.executed = true;\n    }\n\n    // Confirms a transaction if it has not been executed yet\n    function confirmTransaction(uint256 _transactionIndex) external {\n        require(isOwner(msg.sender), \"Only owners can confirm transactions\");\n\n        Transaction storage transaction = pendingTransactions[_transactionIndex];\n\n        require(!transaction.executed, \"Transaction already executed\");\n\n        transaction.confirmations += 1;\n    }\n\n    // Checks if the given address is an owner\n    function isOwner(address _owner) public view returns (bool) {\n        return _isOwner(_owner);\n    }\n\n    // Adds the given address as an owner\n    function _addOwner(address _owner) internal {\n        _owners.push(_owner);\n    }\n\n    // Removes the given address as an owner\n    function _removeOwner(address _owner) internal {\n        uint256 ownerIndex = _owners.indexOf(_owner);\n\n        require(ownerIndex != uint256(-1), \"Owner not found\");\n\n        _owners[ownerIndex] = _owners[_owners.length - 1];\n        _owners.pop();\n    }\n\n    // Returns the list of owners\n    function getOwners() public view returns (address[] memory) {\n        return _owners;\n    }\n\n    // Returns the required confirmations\n    function getRequiredConfirmations() public view returns (uint8) {\n        return requiredConfirmations;\n    }\n\n    // Returns the number of pending transactions\n    function getNumberOfPendingTransactions() public view returns (uint256) {\n        return pendingTransactions.length;\n    }\n\n    // Returns the details of a pending transaction\n    function getPendingTransaction(uint256 _transactionIndex) public view returns (address payable, uint256, uint8, bool) {\n        Transaction storage transaction = pendingTransactions[_transactionIndex];\n\n        return (transaction.to, transaction.value, transaction.confirmations, transaction.executed);\n    }\n\n    // Returns the list of pending transactions\n    function getPendingTransactions() public view returns (Transaction[] memory) {\n        return pendingTransactions;\n    }\n\n    // Returns the address of the contract\n    function getAddress() public view returns (address) {\n        return address(this);\n    }\n\n    // Returns the Solidity version of the contract\n    function getSolidityVersion() public view returns (string memory) {\n        return SolidityVersion.string;\n    }\n\n    // Returns the compiler version of the contract\n    function getCompilerVersion() public view returns (string memory) {\n        return bytes20(keccak256(abi.encodePacked(\n            \"CompilerVersion\",\n            keccak256(abi.encodePacked(\n                compilerVersion\n            ))\n        )));\n    }\n}\n```"
  },
  {
    "prompt": "Design a DAO governance contract with proposal and voting mechanisms",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/Pausable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract DAO is Ownable, Pausable {\n    using SafeMath for uint256;\n\n    struct Proposal {\n        uint256 id;\n        address proposer;\n        string description;\n        uint256 votingDeadline;\n        bool executed;\n        uint256 numberOfVotes;\n    }\n\n    struct Voter {\n        uint256 id;\n        address voterAddress;\n        uint256 vote;\n    }\n\n    Proposal[] public proposals;\n    Voter[] public voters;\n    uint256 public votingDelay;\n    uint256 public votingPeriod;\n    uint256 public minimumQuorum;\n    uint256 public proposalThreshold;\n\n    constructor(\n        uint256 _votingDelay,\n        uint256 _votingPeriod,\n        uint256 _minimumQuorum,\n        uint256 _proposalThreshold\n    ) {\n        votingDelay = _votingDelay;\n        votingPeriod = _votingPeriod;\n        minimumQuorum = _minimumQuorum;\n        proposalThreshold = _proposalThreshold;\n    }\n\n    function propose(string memory _description) external onlyOwner {\n        uint256 proposalId = proposals.length;\n        require(proposalId > 0, \"No proposals have been created yet.\");\n\n        Proposal storage p = proposals[proposalId];\n        p.id = proposalId;\n        p.proposer = msg.sender;\n        p.description = _description;\n        p.votingDeadline = block.timestamp.add(votingDelay);\n        p.executed = false;\n        p.numberOfVotes = 0;\n    }\n\n    function vote(uint256 _proposalId, uint256 _vote) external {\n        require(_proposalId > 0, \"Invalid proposal ID.\");\n        require(_vote == 0 || _vote == 1, \"Invalid vote.\");\n\n        Proposal storage p = proposals[_proposalId];\n        require(block.timestamp <= p.votingDeadline, \"Voting has ended.\");\n\n        Voter storage v = voters[msg.sender];\n        require(v.id == 0, \"You have already voted.\");\n\n        v.id = _proposalId;\n        v.voterAddress = msg.sender;\n        v.vote = _vote;\n\n        p.numberOfVotes = p.numberOfVotes.add(1);\n    }\n\n    function execute(uint256 _proposalId) external onlyOwner {\n        Proposal storage p = proposals[_proposalId];\n        require(p.executed == false, \"Proposal has already been executed.\");\n        require(block.timestamp > p.votingDeadline, \"Voting has not ended yet.\");\n        require(p.numberOfVotes > proposalThreshold, \"Proposal did not meet the threshold.\");\n\n        // Add custom logic to execute the proposal here\n\n        p.executed = true;\n    }\n\n    function pause() external onlyOwner {\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n}\n```"
  },
  {
    "prompt": "Create a decentralized exchange contract for swapping ERC-20 tokens",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\ninterface IERC20 {\n    function approve(address spender, uint256 value) external returns (bool);\n    function transferFrom(address sender, address recipient, uint256 value) external returns (bool);\n}\n\ncontract DecentralizedExchange {\n    IUniswapV2Router02 public uniswap;\n\n    constructor(address _uniswap) {\n        uniswap = IUniswapV2Router02(_uniswap);\n    }\n\n    function swapTokens(address token, uint256 amount) external {\n        IERC20(token).approve(address(uniswap), amount);\n        uniswap.swapExactTokensForTokens(amount, 1, new address[](1), token, block.timestamp);\n    }\n\n    function addLiquidity(address token, uint256 amount, uint256 minLiquidity) external {\n        IERC20(token).approve(address(uniswap), amount);\n        uniswap.addLiquidity(\n            token,\n            amount,\n            1,\n            minLiquidity,\n            address(this),\n            block.timestamp\n        );\n    }\n}\n```"
  },
  {
    "prompt": "Develop a time-locked vault contract that releases funds on a schedule",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\ncontract TimeLockedVault is Ownable {\n    using SafeMath for uint256;\n\n    // The amount of funds locked in the vault\n    uint256 public funds;\n\n    // The schedule for releasing funds\n    uint256[] public releaseSchedule;\n\n    // The current index in the release schedule\n    uint256 private currentReleaseIndex;\n\n    // The constructor sets the initial funds and release schedule\n    constructor(uint256 _funds, uint256[] memory _releaseSchedule) {\n        require(_releaseSchedule.length > 0, \"Release schedule cannot be empty\");\n        require(_funds > 0, \"Funds must be greater than zero\");\n\n        funds = _funds;\n        releaseSchedule = _releaseSchedule;\n    }\n\n    // Only the owner can add funds to the vault\n    function addFunds(uint256 _amount) external onlyOwner {\n        require(_amount > 0, \"Amount must be greater than zero\");\n\n        funds = funds.add(_amount);\n    }\n\n    // Release the next batch of funds if it's time\n    function releaseFunds() external {\n        require(block.timestamp >= releaseSchedule[currentReleaseIndex], \"Funds not yet available for release\");\n\n        uint256 amountToRelease = releaseSchedule[currentReleaseIndex];\n        require(amountToRelease <= funds, \"Insufficient funds to release\");\n\n        funds = funds.sub(amountToRelease);\n        currentReleaseIndex = currentReleaseIndex.add(1);\n    }\n\n    // Returns the amount of funds remaining in the vault\n    function getRemainingFunds() external view returns (uint256) {\n        return funds;\n    }\n\n    // Returns the next release time\n    function getNextReleaseTime() external view returns (uint256) {\n        require(currentReleaseIndex < releaseSchedule.length, \"No more release times available\");\n\n        return releaseSchedule[currentReleaseIndex];\n    }\n}\n```"
  },
  {
    "prompt": "Create an auction contract for NFTs with bidding functionality",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\ncontract NFTAuction is ReentrancyGuard {\n    using Counters for Counters.Counter;\n\n    IERC721 public nft;\n    address public nftOwner;\n    address public highestBidder;\n    uint256 public highestBid;\n    Counters.Counter private bidsCount;\n\n    constructor(address nftAddress) {\n        nft = IERC721(nftAddress);\n        nftOwner = nft.owner();\n    }\n\n    function bid() public payable {\n        require(msg.value > highestBid, \"New bid must be higher than the current highest bid\");\n        require(nftOwner == msg.sender, \"Only the NFT owner can start an auction\");\n\n        _guard();\n\n        nft.transferFrom(nftOwner, address(this), nft.tokenOfOwnerByIndex(nftOwner, 0));\n        highestBidder = payable(msg.sender);\n        highestBid = msg.value;\n\n        _unguard();\n\n        bidsCount.increment();\n    }\n\n    function endAuction() public {\n        require(nftOwner == msg.sender, \"Only the NFT owner can end the auction\");\n\n        _guard();\n\n        require(highestBidder != address(0), \"No bids have been placed yet\");\n        require(highestBid > 0, \"No bids have been placed yet\");\n\n        nft.transferFrom(address(this), highestBidder, nft.tokenOfOwnerByIndex(address(this), 0));\n\n        _unguard();\n\n        emit AuctionEnded(highestBidder, highestBid);\n    }\n\n    event AuctionEnded(address indexed winner, uint256 amount);\n}\n```"
  },
  {
    "prompt": "Design a yield farming contract that rewards liquidity providers",
    "output": "```solidity\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol\";\n\ncontract YieldFarming {\n    IUniswapV2Router02 public uniswap;\n    address public owner;\n\n    // Mapping of user addresses to their LP token balances\n    mapping(address => uint256) public lpTokenBalances;\n\n    // Mapping of user addresses to their pending rewards\n    mapping(address => uint256) public pendingRewards;\n\n    // The address of the LP token\n    IERC20 public lpToken;\n\n    // The reward rate per block\n    uint256 public rewardRate;\n\n    // The address of the reward token\n    IERC20 public rewardToken;\n\n    // The start block of the farming contract\n    uint256 public startBlock;\n\n    // The end block of the farming contract\n    uint256 public endBlock;\n\n    // Event for when a user deposits LP tokens\n    event Deposit(address indexed user, uint256 amount);\n\n    // Event for when a user withdraws LP tokens\n    event Withdraw(address indexed user, uint256 amount);\n\n    // Event for when a user claims their rewards\n    event Claim(address indexed user, uint256 amount);\n\n    constructor(\n        IUniswapV2Router02 _uniswap,\n        IERC20 _lpToken,\n        IERC20 _rewardToken,\n        uint256 _rewardRate,\n        uint256 _startBlock,\n        uint256 _endBlock\n    ) {\n        uniswap = _uniswap;\n        lpToken = _lpToken;\n        rewardToken = _rewardToken;\n        rewardRate = _rewardRate;\n        startBlock = _startBlock;\n        endBlock = _endBlock;\n        owner = msg.sender;\n    }\n\n    // Deposits LP tokens into the contract\n    function deposit(uint256 amount) external {\n        require(block.number >= startBlock, \"Farming has not started yet\");\n        require(block.number <= endBlock, \"Farming has ended\");\n\n        // Transfer LP tokens from the user to the contract\n        lpToken.transferFrom(msg.sender, address(this), amount);\n\n        // Add the LP tokens to the user's balance\n        lpTokenBalances[msg.sender] += amount;\n\n        // Emit the Deposit event\n        emit Deposit(msg.sender, amount);\n    }\n\n    // Withdraws LP tokens from the contract\n    function withdraw(uint256 amount) external {\n        require(lpTokenBalances[msg.sender] >= amount, \"Insufficient LP token balance\");\n\n        // Transfer LP tokens from the contract to the user\n        lpToken.transfer(msg.sender, amount);\n\n        // Subtract the LP tokens from the user's balance\n        lpTokenBalances[msg.sender] -= amount;\n\n        // Emit the Withdraw event\n        emit Withdraw(msg.sender, amount);\n    }\n\n    // Claims the user's pending rewards\n    function claim() external {\n        uint256 rewards = pendingRewards[msg.sender];\n\n        require(rewards > 0, \"No rewards to claim\");\n\n        // Transfer the reward tokens from the contract to the user\n        rewardToken.transfer(msg.sender, rewards);\n\n        // Subtract the rewards from the user's pending rewards\n        pendingRewards[msg.sender] -= rewards;\n\n        // Emit the Claim event\n        emit Claim(msg.sender, rewards);\n    }\n\n    // Calculates the user's pending rewards\n    function calculateRewards() external view returns (uint256) {\n        uint256 balance = lpTokenBalances[msg.sender];\n        uint256 rewards = (balance * (block.timestamp - startBlock)) * rewardRate / 1 blocks;\n\n        return rewards;\n    }\n\n    // Updates the user's pending rewards\n    function updatePendingRewards() external {\n        uint256 rewards = calculateRewards();\n\n        pendingRewards[msg.sender] += rewards;\n    }\n\n    // Allows the owner to set the reward rate\n    function setRewardRate(uint256 _rewardRate) external {\n        require(msg.sender == owner, \"Only the owner can set the reward rate\");\n\n        rewardRate = _rewardRate;\n    }\n\n    // Allows the owner to set the start block\n    function setStartBlock(uint256 _startBlock) external {\n        require(msg.sender == owner, \"Only the owner can set the start block\");\n\n        startBlock = _startBlock;\n    }\n\n    // Allows the owner to set the end block\n    function setEndBlock(uint256 _endBlock) external {\n        require(msg.sender == owner, \"Only the owner can set the end block\");\n\n        endBlock = _endBlock;\n    }\n}\n```"
  }
]